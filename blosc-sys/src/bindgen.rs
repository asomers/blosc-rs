/* automatically generated by rust-bindgen 0.64.0 */

pub const BLOSC_VERSION_MAJOR: u32 = 1;
pub const BLOSC_VERSION_MINOR: u32 = 21;
pub const BLOSC_VERSION_RELEASE: u32 = 4;
pub const BLOSC_VERSION_STRING: &[u8; 11usize] = b"1.21.4.dev\0";
pub const BLOSC_VERSION_REVISION: &[u8; 6usize] = b"$Rev$\0";
pub const BLOSC_VERSION_DATE: &[u8; 22usize] = b"$Date:: 2022-12-15 #$\0";
pub const BLOSC_VERSION_FORMAT: u32 = 2;
pub const BLOSC_MIN_HEADER_LENGTH: u32 = 16;
pub const BLOSC_MAX_OVERHEAD: u32 = 16;
pub const BLOSC_MAX_BUFFERSIZE: u32 = 2147483631;
pub const BLOSC_MAX_TYPESIZE: u32 = 255;
pub const BLOSC_MAX_THREADS: u32 = 256;
pub const BLOSC_NOSHUFFLE: u32 = 0;
pub const BLOSC_SHUFFLE: u32 = 1;
pub const BLOSC_BITSHUFFLE: u32 = 2;
pub const BLOSC_DOSHUFFLE: u32 = 1;
pub const BLOSC_MEMCPYED: u32 = 2;
pub const BLOSC_DOBITSHUFFLE: u32 = 4;
pub const BLOSC_BLOSCLZ: u32 = 0;
pub const BLOSC_LZ4: u32 = 1;
pub const BLOSC_LZ4HC: u32 = 2;
pub const BLOSC_SNAPPY: u32 = 3;
pub const BLOSC_ZLIB: u32 = 4;
pub const BLOSC_ZSTD: u32 = 5;
pub const BLOSC_BLOSCLZ_COMPNAME: &[u8; 8usize] = b"blosclz\0";
pub const BLOSC_LZ4_COMPNAME: &[u8; 4usize] = b"lz4\0";
pub const BLOSC_LZ4HC_COMPNAME: &[u8; 6usize] = b"lz4hc\0";
pub const BLOSC_SNAPPY_COMPNAME: &[u8; 7usize] = b"snappy\0";
pub const BLOSC_ZLIB_COMPNAME: &[u8; 5usize] = b"zlib\0";
pub const BLOSC_ZSTD_COMPNAME: &[u8; 5usize] = b"zstd\0";
pub const BLOSC_BLOSCLZ_LIB: u32 = 0;
pub const BLOSC_LZ4_LIB: u32 = 1;
pub const BLOSC_SNAPPY_LIB: u32 = 2;
pub const BLOSC_ZLIB_LIB: u32 = 3;
pub const BLOSC_ZSTD_LIB: u32 = 4;
pub const BLOSC_BLOSCLZ_LIBNAME: &[u8; 8usize] = b"BloscLZ\0";
pub const BLOSC_LZ4_LIBNAME: &[u8; 4usize] = b"LZ4\0";
pub const BLOSC_SNAPPY_LIBNAME: &[u8; 7usize] = b"Snappy\0";
pub const BLOSC_ZLIB_LIBNAME: &[u8; 5usize] = b"Zlib\0";
pub const BLOSC_ZSTD_LIBNAME: &[u8; 5usize] = b"Zstd\0";
pub const BLOSC_BLOSCLZ_FORMAT: u32 = 0;
pub const BLOSC_LZ4_FORMAT: u32 = 1;
pub const BLOSC_LZ4HC_FORMAT: u32 = 1;
pub const BLOSC_SNAPPY_FORMAT: u32 = 2;
pub const BLOSC_ZLIB_FORMAT: u32 = 3;
pub const BLOSC_ZSTD_FORMAT: u32 = 4;
pub const BLOSC_BLOSCLZ_VERSION_FORMAT: u32 = 1;
pub const BLOSC_LZ4_VERSION_FORMAT: u32 = 1;
pub const BLOSC_LZ4HC_VERSION_FORMAT: u32 = 1;
pub const BLOSC_SNAPPY_VERSION_FORMAT: u32 = 1;
pub const BLOSC_ZLIB_VERSION_FORMAT: u32 = 1;
pub const BLOSC_ZSTD_VERSION_FORMAT: u32 = 1;
pub const BLOSC_ALWAYS_SPLIT: u32 = 1;
pub const BLOSC_NEVER_SPLIT: u32 = 2;
pub const BLOSC_AUTO_SPLIT: u32 = 3;
pub const BLOSC_FORWARD_COMPAT_SPLIT: u32 = 4;
extern "C" {
    #[doc = "Initialize the Blosc library environment.\n\nYou must call this previous to any other Blosc call, unless you want\nBlosc to be used simultaneously in a multi-threaded environment, in\nwhich case you should *exclusively* use the\nblosc_compress_ctx()/blosc_decompress_ctx() pair (see below)."]
    pub fn blosc_init();
}
extern "C" {
    #[doc = "Destroy the Blosc library environment.\n\nYou must call this after to you are done with all the Blosc calls,\nunless you have not used blosc_init() before (see blosc_init()\nabove)."]
    pub fn blosc_destroy();
}
extern "C" {
    #[doc = "Compress a block of data in the `src` buffer and returns the size of\nthe compressed block.  The size of `src` buffer is specified by\n`nbytes`.  There is not a minimum for `src` buffer size (`nbytes`).\n\n`clevel` is the desired compression level and must be a number\nbetween 0 (no compression) and 9 (maximum compression).\n\n`doshuffle` specifies whether the shuffle compression filters\nshould be applied or not.  BLOSC_NOSHUFFLE means not applying it,\nBLOSC_SHUFFLE means applying it at a byte level and BLOSC_BITSHUFFLE\nat a bit level (slower but may achieve better entropy alignment).\n\n`typesize` is the number of bytes for the atomic type in binary\n`src` buffer.  This is mainly useful for the shuffle filters.\nFor implementation reasons, only a 1 < `typesize` < 256 will allow the\nshuffle filter to work.  When `typesize` is not in this range, shuffle\nwill be silently disabled.\n\nThe `dest` buffer must have at least the size of `destsize`.  Blosc\nguarantees that if you set `destsize` to, at least,\n(`nbytes` + BLOSC_MAX_OVERHEAD), the compression will always succeed.\nThe `src` buffer and the `dest` buffer can not overlap.\n\nCompression is memory safe and guaranteed not to write the `dest`\nbuffer beyond what is specified in `destsize`.\n\nIf `src` buffer cannot be compressed into `destsize`, the return\nvalue is zero and you should discard the contents of the `dest`\nbuffer.\n\nA negative return value means that an internal error happened.  This\nshould never happen.  If you see this, please report it back\ntogether with the buffer data causing this and compression settings.\n\nEnvironment variables\n---------------------\n\nblosc_compress() honors different environment variables to control\ninternal parameters without the need of doing that programmatically.\nHere are the ones supported:\n\nBLOSC_CLEVEL=(INTEGER): This will overwrite the `clevel` parameter\nbefore the compression process starts.\n\nBLOSC_SHUFFLE=[NOSHUFFLE | SHUFFLE | BITSHUFFLE]: This will\noverwrite the `doshuffle` parameter before the compression process\nstarts.\n\nBLOSC_TYPESIZE=(INTEGER): This will overwrite the `typesize`\nparameter before the compression process starts.\n\nBLOSC_COMPRESSOR=[BLOSCLZ | LZ4 | LZ4HC | SNAPPY | ZLIB]: This will\ncall blosc_set_compressor(BLOSC_COMPRESSOR) before the compression\nprocess starts.\n\nBLOSC_NTHREADS=(INTEGER): This will call\nblosc_set_nthreads(BLOSC_NTHREADS) before the compression process\nstarts.\n\nBLOSC_BLOCKSIZE=(INTEGER): This will call\nblosc_set_blocksize(BLOSC_BLOCKSIZE) before the compression process\nstarts.  *NOTE:* The blocksize is a critical parameter with\nimportant restrictions in the allowed values, so use this with care.\n\nBLOSC_NOLOCK=(ANY VALUE): This will call blosc_compress_ctx() under\nthe hood, with the `compressor`, `blocksize` and\n`numinternalthreads` parameters set to the same as the last calls to\nblosc_set_compressor(), blosc_set_blocksize() and\nblosc_set_nthreads().  BLOSC_CLEVEL, BLOSC_SHUFFLE, BLOSC_TYPESIZE\nenvironment vars will also be honored.\n\nBLOSC_SPLITMODE=[ FORWARD_COMPAT | AUTO | ALWAYS | NEVER ]:\nThis will call blosc_set_splitmode() with the different supported values.\nSee blosc_set_splitmode() docstrings for more info on each mode.\n\nBLOSC_WARN=(INTEGER): This will print some warning message on stderr\nshowing more info in situations where data inputs cannot be compressed.\nThe values can range from 1 (less verbose) to 10 (full verbose).  0 is\nthe same as if the BLOSC_WARN envvar was not defined."]
    pub fn blosc_compress(
        clevel: ::std::os::raw::c_int,
        doshuffle: ::std::os::raw::c_int,
        typesize: usize,
        nbytes: usize,
        src: *const ::std::os::raw::c_void,
        dest: *mut ::std::os::raw::c_void,
        destsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Context interface to blosc compression. This does not require a call\nto blosc_init() and can be called from multithreaded applications\nwithout the global lock being used, so allowing Blosc be executed\nsimultaneously in those scenarios.\n\nIt uses the same parameters than the blosc_compress() function plus:\n\n`compressor`: the string representing the type of compressor to use.\n\n`blocksize`: the requested size of the compressed blocks.  If 0, an\nautomatic blocksize will be used.\n\n`numinternalthreads`: the number of threads to use internally.\n\nA negative return value means that an internal error happened.  This\nshould never happen.  If you see this, please report it back\ntogether with the buffer data causing this and compression settings."]
    pub fn blosc_compress_ctx(
        clevel: ::std::os::raw::c_int,
        doshuffle: ::std::os::raw::c_int,
        typesize: usize,
        nbytes: usize,
        src: *const ::std::os::raw::c_void,
        dest: *mut ::std::os::raw::c_void,
        destsize: usize,
        compressor: *const ::std::os::raw::c_char,
        blocksize: usize,
        numinternalthreads: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Decompress a block of compressed data in `src`, put the result in\n`dest` and returns the size of the decompressed block.\n\nCall `blosc_cbuffer_validate` to determine the size of the destination buffer.\n\nThe `src` buffer and the `dest` buffer can not overlap.\n\nDecompression is memory safe and guaranteed not to write the `dest`\nbuffer beyond what is specified in `destsize`.\n\nIf an error occurs, e.g. the compressed data is corrupted or the\noutput buffer is not large enough, then 0 (zero) or a negative value\nwill be returned instead.\n\nEnvironment variables\n---------------------\n\nblosc_decompress() honors different environment variables to control\ninternal parameters without the need of doing that programmatically.\nHere are the ones supported:\n\nBLOSC_NTHREADS=(INTEGER): This will call\nblosc_set_nthreads(BLOSC_NTHREADS) before the proper decompression\nprocess starts.\n\nBLOSC_NOLOCK=(ANY VALUE): This will call blosc_decompress_ctx()\nunder the hood, with the `numinternalthreads` parameter set to the\nsame value as the last call to blosc_set_nthreads()."]
    pub fn blosc_decompress(
        src: *const ::std::os::raw::c_void,
        dest: *mut ::std::os::raw::c_void,
        destsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Context interface to blosc decompression. This does not require a\ncall to blosc_init() and can be called from multithreaded\napplications without the global lock being used, so allowing Blosc\nbe executed simultaneously in those scenarios.\n\nCall `blosc_cbuffer_validate` to determine the size of the destination buffer.\n\nIt uses the same parameters than the blosc_decompress() function plus:\n\n`numinternalthreads`: number of threads to use internally.\n\nDecompression is memory safe and guaranteed not to write the `dest`\nbuffer more than what is specified in `destsize`.\n\nIf an error occurs, e.g. the compressed data is corrupted or the\noutput buffer is not large enough, then 0 (zero) or a negative value\nwill be returned instead."]
    pub fn blosc_decompress_ctx(
        src: *const ::std::os::raw::c_void,
        dest: *mut ::std::os::raw::c_void,
        destsize: usize,
        numinternalthreads: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get `nitems` (of typesize size) in `src` buffer starting in `start`.\nThe items are returned in `dest` buffer, which has to have enough\nspace for storing all items.\n\nReturns the number of bytes copied to `dest` or a negative value if\nsome error happens."]
    pub fn blosc_getitem(
        src: *const ::std::os::raw::c_void,
        start: ::std::os::raw::c_int,
        nitems: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the current number of threads that are used for\ncompression/decompression."]
    pub fn blosc_get_nthreads() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Initialize a pool of threads for compression/decompression.  If\n`nthreads` is 1, then the serial version is chosen and a possible\nprevious existing pool is ended.  If this is not called, `nthreads`\nis set to 1 internally.\n\nReturns the previous number of threads."]
    pub fn blosc_set_nthreads(nthreads: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the current compressor that is being used for compression."]
    pub fn blosc_get_compressor() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Select the compressor to be used.  The supported ones are \"blosclz\",\n\"lz4\", \"lz4hc\", \"snappy\", \"zlib\" and \"zstd\".  If this function is not\ncalled, then \"blosclz\" will be used by default.\n\nIn case the compressor is not recognized, or there is not support\nfor it in this build, it returns a -1.  Else it returns the code for\nthe compressor (>=0)."]
    pub fn blosc_set_compressor(compname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the `compname` associated with the `compcode`.\n\nIf the compressor code is not recognized, or there is not support\nfor it in this build, -1 is returned.  Else, the compressor code is\nreturned."]
    pub fn blosc_compcode_to_compname(
        compcode: ::std::os::raw::c_int,
        compname: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the compressor code associated with the compressor name.\n\nIf the compressor name is not recognized, or there is not support\nfor it in this build, -1 is returned instead."]
    pub fn blosc_compname_to_compcode(
        compname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get a list of compressors supported in the current build.  The\nreturned value is a string with a concatenation of \"blosclz\", \"lz4\",\n\"lz4hc\", \"snappy\", \"zlib\" or \"zstd \"separated by commas, depending\non which ones are present in the build.\n\nThis function does not leak, so you should not free() the returned\nlist.\n\nThis function should always succeed."]
    pub fn blosc_list_compressors() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Return the version of the C-Blosc library in string format.\n\nUseful for dynamic libraries."]
    pub fn blosc_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get info from compression libraries included in the current build.\nIn `compname` you pass the compressor name that you want info from.\n\nIn `complib` and `version` you get a pointer to the compressor\nlibrary name and the version in string format respectively.  After\nusing the name and version, you should free() them so as to avoid\nleaks.  If any of `complib` and `version` are NULL, they will not be\nassigned to anything, and the user should not need to free them.\n\nIf the compressor is supported, it returns the code for the library\n(>=0).  If it is not supported, this function returns -1."]
    pub fn blosc_get_complib_info(
        compname: *const ::std::os::raw::c_char,
        complib: *mut *mut ::std::os::raw::c_char,
        version: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Free possible memory temporaries and thread resources.  Use this\nwhen you are not going to use Blosc for a long while.  In case of\nproblems releasing the resources, it returns a negative number, else\nit returns 0."]
    pub fn blosc_free_resources() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return information about a compressed buffer, namely the number of\nuncompressed bytes (`nbytes`) and compressed (`cbytes`).  It also\nreturns the `blocksize` (which is used internally for doing the\ncompression by blocks).\n\nYou only need to pass the first BLOSC_MIN_HEADER_LENGTH bytes of a\ncompressed buffer for this call to work.\n\nIf the format is not supported by the library, all output arguments will be\nfilled with zeros."]
    pub fn blosc_cbuffer_sizes(
        cbuffer: *const ::std::os::raw::c_void,
        nbytes: *mut usize,
        cbytes: *mut usize,
        blocksize: *mut usize,
    );
}
extern "C" {
    #[doc = "Checks that the compressed buffer starting at `cbuffer` of length `cbytes` may\ncontain valid blosc compressed data, and that it is safe to call\nblosc_decompress/blosc_decompress_ctx/blosc_getitem.\n\nOn success, returns 0 and sets *nbytes to the size of the uncompressed data.\nThis does not guarantee that the decompression function won't return an error,\nbut does guarantee that it is safe to attempt decompression.\n\nOn failure, returns -1."]
    pub fn blosc_cbuffer_validate(
        cbuffer: *const ::std::os::raw::c_void,
        cbytes: usize,
        nbytes: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return meta-information about a compressed buffer, namely the type size\n(`typesize`), as well as some internal `flags`.\n\nThe `flags` is a set of bits, where the used ones are:\n bit 0: whether the shuffle filter has been applied or not\n bit 1: whether the internal buffer is a pure memcpy or not\n bit 2: whether the bit shuffle filter has been applied or not\n\nYou can use the `BLOSC_DOSHUFFLE`, `BLOSC_DOBITSHUFFLE` and\n`BLOSC_MEMCPYED` symbols for extracting the interesting bits\n(e.g. ``flags & BLOSC_DOSHUFFLE`` says whether the buffer is\nbyte-shuffled or not).\n\nYou only need to pass the first BLOSC_MIN_HEADER_LENGTH bytes of a\ncompressed buffer for this call to work.\n\nIf the format is not supported by the library, all output arguments will be\nfilled with zeros."]
    pub fn blosc_cbuffer_metainfo(
        cbuffer: *const ::std::os::raw::c_void,
        typesize: *mut usize,
        flags: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "Return information about a compressed buffer, namely the internal\nBlosc format version (`version`) and the format for the internal\ncompressor used (`compversion`).\n\nThis function should always succeed."]
    pub fn blosc_cbuffer_versions(
        cbuffer: *const ::std::os::raw::c_void,
        version: *mut ::std::os::raw::c_int,
        compversion: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "Return the compressor library/format used in a compressed buffer.\n\nThis function should always succeed."]
    pub fn blosc_cbuffer_complib(
        cbuffer: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Get the internal blocksize to be used during compression.  0 means\nthat an automatic blocksize is computed internally (the default)."]
    pub fn blosc_get_blocksize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Force the use of a specific blocksize.  If 0, an automatic\nblocksize will be used (the default).\n\nThe blocksize is a critical parameter with important restrictions in\nthe allowed values, so use this with care."]
    pub fn blosc_set_blocksize(blocksize: usize);
}
extern "C" {
    #[doc = "Set the split mode.\n\nThis function can take the next values:\n  BLOSC_FORWARD_COMPAT_SPLIT\n  BLOSC_AUTO_SPLIT\n  BLOSC_NEVER_SPLIT\n  BLOSC_ALWAYS_SPLIT\n\nBLOSC_FORWARD_COMPAT offers reasonably forward compatibility,\nBLOSC_AUTO_SPLIT is for nearly optimal results (based on heuristics),\nBLOSC_NEVER_SPLIT and BLOSC_ALWAYS_SPLIT are for the user experimenting\nwhen trying to get best compression ratios and/or speed.\n\nIf not called, the default mode is BLOSC_FORWARD_COMPAT_SPLIT.\n\nThis function should always succeed."]
    pub fn blosc_set_splitmode(splitmode: ::std::os::raw::c_int);
}
